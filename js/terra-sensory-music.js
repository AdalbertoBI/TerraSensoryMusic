// TerraSensoryMusic - Sistema Principal
// Integra√ß√£o de todos os m√≥dulos para monitoramento MIDI Terra Eletr√¥nica

class TerraSensoryMusicSystem {
    constructor() {
        this.version = '2.0.0';
        this.isConnected = false;
        this.isPaused = false;
        
        // Inst√¢ncias dos m√≥dulos
        this.diagnosticSystem = new DiagnosticSystem();
        this.midiDetector = new MidiDetector();
        this.uiManager = new UIManager();
        this.midiParser = new MidiParser();
        
        // Dados
        this.midiLog = [];
        this.filteredLog = [];
        this.stats = {
            totalMessages: 0,
            messagesPerSecond: 0,
            activeChannels: new Set(),
            connectedDevices: 0
        };
        
        this.messageRateCounter = 0;
        this.channels = new Map();
        
        // Inicializar sistema
        this.initialize();
    }

    async initialize() {
        console.log(`üéµ Inicializando TerraSensoryMusic v${this.version}...`);
        
        try {
            // Inicializar UI Manager
            this.uiManager.initialize();
            
            // Configurar interface
            this.setupUI();
            this.setupChannels();
            
            // Iniciar sistema de estat√≠sticas
            this.startStatsUpdater();
            
            // Verificar suporte Web MIDI
            this.checkWebMIDISupport();
            
            // Configurar callbacks do detector MIDI
            this.setupMidiDetectorCallbacks();
            
            console.log('‚úÖ TerraSensoryMusic inicializado com sucesso!');
            
            // Mostrar mensagem de boas-vindas
            this.showWelcomeMessage();
            
        } catch (error) {
            console.error('‚ùå Erro ao inicializar TerraSensoryMusic:', error);
            this.uiManager.showNotification('Erro ao inicializar o sistema: ' + error.message, 'error');
        }
    }

    setupUI() {
        // Event listeners dos bot√µes principais
        const buttons = {
            connectBtn: () => this.toggleConnection(),
            clearLog: () => this.clearLog(),
            pauseBtn: () => this.togglePause(),
            exportBtn: () => this.exportLog(),
            diagnoseBtn: () => this.runDiagnosis(),
            rescanBtn: () => this.forceScan()
        };

        Object.entries(buttons).forEach(([id, handler]) => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('click', handler);
            }
        });

        // Event listeners dos filtros
        const filters = ['channelFilter', 'messageType', 'slaveFilter'];
        filters.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('change', () => this.applyFilters());
            }
        });

        // Modal
        const modalClose = document.getElementById('modalClose');
        if (modalClose) {
            modalClose.addEventListener('click', () => this.uiManager.closeModal());
        }

        const messageModal = document.getElementById('messageModal');
        if (messageModal) {
            messageModal.addEventListener('click', (e) => {
                if (e.target.id === 'messageModal') this.uiManager.closeModal();
            });
        }

        // Configurar sistema de abas
        this.setupTabs();
    }

    setupTabs() {
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabPanels = document.querySelectorAll('.tab-panel');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetTab = button.getAttribute('data-tab');
                
                // Remover classe active de todas as abas e pain√©is
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabPanels.forEach(panel => panel.classList.remove('active'));
                
                // Ativar a aba clicada
                button.classList.add('active');
                const targetPanel = document.getElementById(targetTab + '-panel');
                if (targetPanel) {
                    targetPanel.classList.add('active');
                }

                // Log para debug
                console.log(`üîÑ Aba ativada: ${targetTab}`);
            });
        });
    }

    setupChannels() {
        const channelsGrid = document.getElementById('channelsGrid');
        if (!channelsGrid) return;

        // Criar cards para cada canal MIDI (0-15)
        for (let i = 0; i < 16; i++) {
            const channelCard = document.createElement('div');
            channelCard.className = 'channel-card';
            channelCard.id = `channel-${i}`;
            
            channelCard.innerHTML = `
                <div class="channel-number">Canal ${i}</div>
                <div class="channel-hex">CH ${i}</div>
                <div class="channel-status">Inativo</div>
                <div class="channel-activity">
                    <div class="channel-activity-bar"></div>
                </div>
            `;
            
            channelsGrid.appendChild(channelCard);
            this.channels.set(i, {
                element: channelCard,
                lastActivity: 0,
                messageCount: 0
            });
        }
    }

    setupMidiDetectorCallbacks() {
        // Callback para mudan√ßas de estado dos dispositivos
        this.midiDetector.onDeviceStateChange((event) => {
            this.handleDeviceStateChange(event);
        });
    }

    checkWebMIDISupport() {
        if (!navigator.requestMIDIAccess) {
            const message = 'Web MIDI API n√£o suportada. Use Chrome, Edge ou Opera.';
            this.uiManager.showNotification(message, 'error');
            this.diagnosticSystem.log(message, 'error');
            return false;
        }
        
        this.diagnosticSystem.log('‚úÖ Web MIDI API suportada', 'success');
        return true;
    }

    showWelcomeMessage() {
        setTimeout(() => {
            this.uiManager.showNotification(
                'üéØ TerraSensoryMusic v2.0 iniciado! Conecte seu dispositivo Terra via USB e clique em "Conectar MIDI".',
                'terra',
                10000
            );
        }, 1000);
    }

    // M√©todos de conex√£o
    async toggleConnection() {
        if (this.isConnected) {
            this.disconnect();
        } else {
            await this.connect();
        }
    }

    async connect() {
        try {
            this.uiManager.updateConnectionStatus('connecting');
            this.uiManager.showNotification('üîÑ Conectando... Aguarde resposta do navegador', 'info', 3000);
            this.diagnosticSystem.log('üîÑ Iniciando conex√£o MIDI...', 'info');
            this.diagnosticSystem.log('üí° Dispositivo "Midi-Terra" detectado no Windows - tentando acessar via Web MIDI...', 'info');
            
            // Inicializar detector MIDI
            await this.midiDetector.initialize();
            
            // üî• CORRE√á√ÉO: Registrar callback ao inv√©s de configurar handlers
            this.midiDetector.onMidiMessage((event, deviceInfo) => {
                this.handleMidiMessage(event, deviceInfo);
            });
            
            this.isConnected = true;
            this.uiManager.updateConnectionStatus('connected');
            
            const terraDevices = this.midiDetector.getTerraDevices();
            const allInputs = this.midiDetector.getAllInputs();
            
            this.stats.connectedDevices = allInputs.length;
            this.uiManager.updateStats(this.stats);
            
            // Verifica√ß√£o espec√≠fica para Midi-Terra
            const midiTerraFound = allInputs.find(device => 
                device.name.toLowerCase().includes('midi-terra') || 
                device.name.toLowerCase().includes('miditerra')
            );
            
            if (midiTerraFound) {
                this.uiManager.showNotification(`üéØ MIDI-TERRA CONECTADO: ${midiTerraFound.name}`, 'terra');
                this.diagnosticSystem.log(`üéØ SUCESSO: Midi-Terra detectado como "${midiTerraFound.name}"`, 'terra');
            } else if (terraDevices.length > 0) {
                const deviceNames = terraDevices.map(d => d.name).join(', ');
                this.uiManager.showNotification(`üîç Dispositivos Terra detectados: ${deviceNames}`, 'terra');
                this.diagnosticSystem.log(`üîç Dispositivos Terra encontrados (pode incluir Midi-Terra): ${deviceNames}`, 'info');
            } else if (allInputs.length > 0) {
                this.uiManager.showNotification(`‚ö†Ô∏è ${allInputs.length} dispositivos MIDI detectados, mas nenhum identificado como Terra`, 'warning');
                this.diagnosticSystem.log(`‚ö†Ô∏è Dispositivos gen√©ricos encontrados (Midi-Terra pode estar entre eles):`, 'warning');
                allInputs.forEach((device, index) => {
                    this.diagnosticSystem.log(`   ${index + 1}. "${device.name}" (${device.manufacturer})`, 'info');
                });
                this.uiManager.showNotification('üí° Use "üîç Diagnosticar" para an√°lise detalhada', 'info');
            } else {
                this.uiManager.showNotification('‚ùå Nenhum dispositivo MIDI acess√≠vel via Web MIDI API', 'error');
                this.diagnosticSystem.log('‚ùå PROBLEMA: Midi-Terra vis√≠vel no Windows mas n√£o acess√≠vel via navegador', 'error');
                this.diagnosticSystem.log('üí° Poss√≠veis causas: drivers, permiss√µes ou configura√ß√£o do dispositivo', 'warning');
            }
            
        } catch (error) {
            console.error('‚ùå Erro ao conectar:', error);
            
            // Usar informa√ß√µes enriquecidas do erro se dispon√≠vel
            const userMessage = error.userMessage || error.message;
            const technicalMessage = error.technicalMessage || error.message;
            
            this.diagnosticSystem.log(`‚ùå Erro de conex√£o: ${technicalMessage}`, 'error');
            
            // Mostrar mensagem espec√≠fica baseada no tipo de erro
            if (error.message.includes('Timeout')) {
                this.uiManager.showNotification('‚è∞ Timeout: Clique em "üîÑ Re-escanear" para tentar novamente', 'warning');
                this.diagnosticSystem.log('üí° Dica: Verifique se n√£o h√° popup de permiss√£o aguardando resposta', 'info');
            } else if (error.originalError?.name === 'SecurityError' || error.message.includes('Permiss√£o negada')) {
                this.uiManager.showNotification('üîí Permiss√£o negada. Clique em "üîÑ Re-escanear" e permita o acesso MIDI', 'error');
                this.diagnosticSystem.log('üí° Dica: Procure por popup de permiss√£o ou recarregue a p√°gina', 'info');
            } else if (error.originalError?.name === 'NotSupportedError') {
                this.uiManager.showNotification('‚ùå Navegador n√£o suporta Web MIDI. Use Chrome, Edge ou Opera', 'error');
                this.diagnosticSystem.log('üí° Solu√ß√£o: Mude para um navegador compat√≠vel', 'warning');
            } else {
                this.uiManager.showNotification(`‚ùå ${userMessage}`, 'error');
            }
            
            // Verificar se deve tentar retry autom√°tico
            if (error.shouldAutoRetry && error.retryAttempt < error.maxRetries) {
                const nextAttempt = error.retryAttempt + 1;
                this.uiManager.showNotification(`üîÑ Tentativa ${nextAttempt}/${error.maxRetries} em 3 segundos...`, 'info', 3000);
                this.diagnosticSystem.log(`üîÑ Agendando retry autom√°tico ${nextAttempt}/${error.maxRetries}`, 'info');
                
                setTimeout(async () => {
                    this.diagnosticSystem.log(`üîÑ Executando retry autom√°tico ${nextAttempt}/${error.maxRetries}`, 'info');
                    await this.connect();
                }, 3000);
                
                return; // N√£o entrar em fallback ainda
            }
            
            // Se n√£o h√° mais retries ou erro n√£o √© recuper√°vel
            if (error.retryAttempt >= error.maxRetries) {
                this.uiManager.showNotification(`‚ùå Falha ap√≥s ${error.maxRetries} tentativas. Use "üîÑ Re-escanear" para tentar novamente`, 'error');
                this.diagnosticSystem.log(`‚ùå Todas as tentativas autom√°ticas falharam (${error.maxRetries}/${error.maxRetries})`, 'error');
            } else if (error.isRetryable !== false) {
                setTimeout(() => {
                    this.uiManager.showNotification('üîÑ Clique em "Re-escanear" para tentar novamente', 'info');
                }, 2000);
            }
            
            // Entrar em modo fallback para manter funcionalidade
            this.enableFallbackMode();
        }
    }

    disconnect() {
        this.isConnected = false;
        this.uiManager.updateConnectionStatus('disconnected');
        this.uiManager.showNotification('üîå Desconectado dos dispositivos MIDI', 'info');
        this.diagnosticSystem.log('üîå Sistema desconectado', 'info');
    }

    // üî• REMOVIDO: setupMidiMessageHandlers - agora usa callback system

    handleMidiMessage(event, deviceInfo) {
        if (this.isPaused || !event.data) return;

        // üî• DEBUG: Verificar se est√° recebendo mensagens
        console.log('üéØ Sistema principal recebeu mensagem MIDI:', {
            device: deviceInfo.name,
            data: Array.from(event.data).map(b => '0x' + b.toString(16).toUpperCase().padStart(2, '0')).join(' ')
        });

        // Usar o parser para interpretar a mensagem
        const parsedMessage = this.midiParser.parseMessage(
            event.data, 
            new Date(), 
            deviceInfo
        );

        // Adicionar informa√ß√µes extras
        parsedMessage.deviceName = deviceInfo.name;
        parsedMessage.isTerraDevice = deviceInfo.isTerraDevice;

        // Adicionar ao log
        this.midiLog.push(parsedMessage);

        // Atualizar estat√≠sticas
        this.updateStats(parsedMessage);

        // Atualizar atividade dos canais
        this.updateChannelActivity(parsedMessage);

        // Aplicar filtros e atualizar interface
        this.applyFilters();

        // Log detalhado para dispositivos Terra
        if (deviceInfo.isTerraDevice) {
            this.diagnosticSystem.log(
                `üéµ Terra MIDI: ${parsedMessage.type} | Canal: ${parsedMessage.channel} | Dados: ${parsedMessage.rawData?.map(b => '0x' + b.toString(16).toUpperCase().padStart(2, '0')).join(' ')}`,
                'terra'
            );
        }
    }

    handleDeviceStateChange(event) {
        const port = event.port;
        const action = port.state === 'connected' ? 'conectado' : 'desconectado';
        
        this.diagnosticSystem.log(`üîÑ Dispositivo ${action}: ${port.name}`, 'info');
        
        // Se √© um dispositivo Terra sendo conectado
        if (port.state === 'connected') {
            const isTerra = this.midiDetector.identifyTerraDevice(port);
            if (isTerra) {
                this.uiManager.showNotification(`üéØ Dispositivo Terra conectado: ${port.name}`, 'terra');
            }
        }
        
        // Atualizar contadores
        const allInputs = this.midiDetector.getAllInputs();
        this.stats.connectedDevices = allInputs.length;
        this.uiManager.updateStats(this.stats);
    }

    updateStats(message) {
        this.stats.totalMessages++;
        this.messageRateCounter++;
        
        if (typeof message.channel === 'number') {
            this.stats.activeChannels.add(message.channel);
        }
        
        this.uiManager.updateStats({
            ...this.stats,
            activeChannels: this.stats.activeChannels.size
        });
    }

    updateChannelActivity(message) {
        if (typeof message.channel !== 'number') {
            console.log('‚ö†Ô∏è Canal inv√°lido:', message.channel);
            return;
        }
        
        // üî• DEBUG: Atividade do canal
        console.log('üìä Atualizando canal:', message.channel, 'tipo:', message.type);
        
        const channel = this.channels.get(message.channel);
        
        if (channel) {
            channel.lastActivity = Date.now();
            channel.messageCount++;
            
            this.uiManager.updateChannelActivity(message.channel, true);
            
            // Auto-desativar ap√≥s 2 segundos
            setTimeout(() => {
                if (Date.now() - channel.lastActivity >= 2000) {
                    this.uiManager.updateChannelActivity(message.channel, false);
                }
            }, 2000);
        }
    }

    // M√©todos de filtros e interface
    applyFilters() {
        const channelFilter = document.getElementById('channelFilter')?.value;
        const typeFilter = document.getElementById('messageType')?.value;
        
        // üî• DEBUG: Verificar aplica√ß√£o de filtros
        console.log('üîç Aplicando filtros:', {
            totalMessages: this.midiLog.length,
            channelFilter,
            typeFilter
        });
        
        this.filteredLog = this.midiLog.filter(message => {
            if (channelFilter && message.channel !== parseInt(channelFilter.replace('0x9', ''))) {
                return false;
            }
            
            if (typeFilter && message.type !== typeFilter) {
                return false;
            }
            
            return true;
        });
        
        // üî• DEBUG: Verificar resultado dos filtros
        console.log('üîç Resultado dos filtros:', {
            filtered: this.filteredLog.length,
            total: this.midiLog.length
        });
        
        this.uiManager.updateLogDisplay(this.filteredLog, this.filteredLog.length);
    }

    // M√©todos de controle
    togglePause() {
        this.isPaused = !this.isPaused;
        const pauseBtn = document.getElementById('pauseBtn');
        
        if (pauseBtn) {
            pauseBtn.textContent = this.isPaused ? 'Retomar' : 'Pausar';
            pauseBtn.className = this.isPaused ? 'btn btn-success' : 'btn btn-warning';
        }
        
        const message = this.isPaused ? '‚è∏Ô∏è Monitoramento pausado' : '‚ñ∂Ô∏è Monitoramento retomado';
        this.uiManager.showNotification(message, 'info');
        this.diagnosticSystem.log(message, 'info');
    }

    clearLog() {
        this.midiLog = [];
        this.filteredLog = [];
        
        this.stats.totalMessages = 0;
        this.stats.activeChannels.clear();
        
        this.uiManager.updateStats(this.stats);
        this.uiManager.clearLog();
        
        // Limpar atividade dos canais
        this.channels.forEach((channel, channelNum) => {
            this.uiManager.updateChannelActivity(channelNum, false);
        });
        
        this.uiManager.showNotification('üóëÔ∏è Log limpo', 'info');
        this.diagnosticSystem.log('üóëÔ∏è Log de mensagens limpo', 'info');
    }

    exportLog() {
        const data = {
            timestamp: new Date().toISOString(),
            version: this.version,
            stats: {
                ...this.stats,
                activeChannels: Array.from(this.stats.activeChannels)
            },
            devices: this.midiDetector.getTerraDevices(),
            messages: this.midiLog,
            messageStats: this.midiParser.getMessageStats(this.midiLog)
        };

        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `terra-sensory-music-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        this.uiManager.showNotification('üìÅ Log exportado com sucesso!', 'success');
        this.diagnosticSystem.log('üìÅ Dados exportados', 'success');
    }

    // M√©todo para for√ßar re-scan de dispositivos
    async forceScan() {
        this.diagnosticSystem.log('üîÑ For√ßando novo scan de dispositivos...', 'info');
        this.uiManager.showNotification('üîÑ Re-escaneando dispositivos MIDI...', 'info');
        
        // Resetar estado de retry para nova tentativa manual
        if (this.midiDetector) {
            this.midiDetector.resetRetryState();
        }
        
        // Se estiver em modo fallback ou n√£o conectado, tentar conectar novamente
        if (!this.isConnected || !this.midiDetector || !this.midiDetector.midiAccess) {
            this.diagnosticSystem.log('üîÑ Tentando reconectar MIDI...', 'info');
            await this.connect();
            return;
        }
        
        // Se j√° conectado, fazer apenas scan
        if (this.midiDetector) {
            this.midiDetector.forceScan();
            
            // Atualizar interface ap√≥s scan
            setTimeout(() => {
                const terraDevices = this.midiDetector.getTerraDevices();
                const allInputs = this.midiDetector.getAllInputs();
                
                this.stats.connectedDevices = allInputs.length;
                this.uiManager.updateStats(this.stats);
                
                if (terraDevices.length > 0) {
                    const deviceNames = terraDevices.map(d => d.name).join(', ');
                    this.uiManager.showNotification(`üéØ Dispositivos Terra encontrados: ${deviceNames}`, 'terra');
                    this.diagnosticSystem.log(`üéØ Re-scan conclu√≠do: ${terraDevices.length} dispositivos Terra`, 'terra');
                } else if (allInputs.length > 0) {
                    this.uiManager.showNotification(`üìä ${allInputs.length} dispositivos MIDI encontrados (nenhum Terra)`, 'warning');
                    this.diagnosticSystem.log(`üìä Re-scan: ${allInputs.length} dispositivos gen√©ricos, 0 Terra`, 'warning');
                } else {
                    this.uiManager.showNotification('‚ùå Nenhum dispositivo MIDI encontrado no re-scan', 'error');
                    this.diagnosticSystem.log('‚ùå Re-scan: nenhum dispositivo encontrado', 'error');
                }
            }, 500);
        }
    }

    // Diagn√≥stico
    async runDiagnosis() {
        this.diagnosticSystem.log('üîç Executando diagn√≥stico completo...', 'info');
        
        try {
            const reportHtml = await this.diagnosticSystem.runFullDiagnosis();
            
            this.uiManager.showModal('üîç Diagn√≥stico do Sistema MIDI', reportHtml, {
                onClose: () => {
                    this.diagnosticSystem.log('üìã Diagn√≥stico conclu√≠do', 'success');
                }
            });
            
        } catch (error) {
            console.error('‚ùå Erro no diagn√≥stico:', error);
            this.uiManager.showNotification(`Erro no diagn√≥stico: ${error.message}`, 'error');
        }
    }

    showMessageDetails(index) {
        if (index < 0 || index >= this.filteredLog.length) return;
        
        const message = this.filteredLog[index];
        
        let detailsHtml = `
            <div class="message-details">
                <h5>Detalhes da Mensagem MIDI</h5>
                <div><strong>Timestamp:</strong> ${message.timestamp.toLocaleString('pt-BR')}</div>
                <div><strong>Dispositivo:</strong> ${message.deviceName || 'Desconhecido'}</div>
                <div><strong>Terra Device:</strong> ${message.isTerraDevice ? 'üéØ SIM' : 'N√£o'}</div>
                <div><strong>Tipo:</strong> ${message.type}</div>
                <div><strong>Canal:</strong> ${typeof message.channel === 'number' ? `Canal ${message.channel}` : 'N/A'}</div>
        `;

        if (message.note !== undefined) {
            detailsHtml += `<div><strong>Nota:</strong> ${message.note} (${message.noteName || 'N/A'})</div>`;
            if (message.frequency) {
                detailsHtml += `<div><strong>Frequ√™ncia:</strong> ${message.frequency.toFixed(2)} Hz</div>`;
            }
        }

        if (message.velocity !== undefined) {
            detailsHtml += `<div><strong>Velocity:</strong> ${message.velocity}</div>`;
        }

        if (message.controller !== undefined) {
            detailsHtml += `<div><strong>Controller:</strong> ${message.controller} (${message.controllerName || 'CC' + message.controller})</div>`;
        }

        if (message.value !== undefined) {
            detailsHtml += `<div><strong>Value:</strong> ${message.value}</div>`;
        }

        if (message.terraSpecific) {
            detailsHtml += `<div class="terra-specific"><strong>üéØ Espec√≠fico Terra:</strong> SIM</div>`;
        }

        detailsHtml += `
                <div><strong>Dados Brutos:</strong> ${message.rawData ? message.rawData.map(b => `0x${b.toString(16).toUpperCase().padStart(2, '0')}`).join(' ') : 'N/A'}</div>
                <div><strong>MIDI V√°lido:</strong> ${message.isValidMidi ? '‚úÖ' : '‚ùå'}</div>
            </div>
        `;

        this.uiManager.showModal('Detalhes da Mensagem', detailsHtml);
    }

    // M√©todo de fallback quando MIDI n√£o est√° dispon√≠vel
    enableFallbackMode() {
        console.log('üîÑ Entrando em modo fallback...');
        this.diagnosticSystem.log('üîÑ Entrando em modo fallback - interface funcional sem MIDI', 'warning');
        
        // Simular conex√£o parcial para manter a interface funcionando
        this.isConnected = false;
        this.uiManager.updateConnectionStatus('fallback');
        
        // Mostrar instru√ß√µes claras
        const fallbackMessage = `
            <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 8px; margin: 10px 0;">
                <h4>üîß Modo Diagn√≥stico Ativo</h4>
                <p><strong>A interface est√° funcionando sem conex√£o MIDI real.</strong></p>
                
                <h5>üí° Para conectar o Midi-Terra:</h5>
                <ol>
                    <li>Verifique se o dispositivo est√° conectado via USB</li>
                    <li>Confirme que aparece no Gerenciador de Dispositivos do Windows</li>
                    <li>Clique em "üîÑ Re-escanear" para tentar novamente</li>
                    <li>Se aparecer popup de permiss√£o, clique em "Permitir" <strong>rapidamente</strong></li>
                    <li>O sistema far√° 3 tentativas autom√°ticas com timeouts crescentes (5s, 10s, 15s)</li>
                </ol>
                
                <h5>üõ†Ô∏è Diagn√≥stico avan√ßado:</h5>
                <ul>
                    <li>Clique em "üîç Diagnosticar" para an√°lise completa</li>
                    <li>Use "üîÑ Re-escanear" para nova tentativa (reseta contador)</li>
                    <li>Verifique o Console do navegador (F12) para logs detalhados</li>
                </ul>
                
                <h5>‚ö†Ô∏è Poss√≠veis causas do timeout:</h5>
                <ul>
                    <li>Popup de permiss√£o n√£o foi respondido a tempo</li>
                    <li>Conflito com outro software MIDI</li>
                    <li>Problema de driver do dispositivo Midi-Terra</li>
                    <li>Pol√≠tica de seguran√ßa do navegador/empresa</li>
                </ul>
            </div>
        `;
        
        // Mostrar no log
        const logContainer = document.getElementById('logContainer');
        if (logContainer) {
            logContainer.innerHTML = `
                <div class="log-message fallback-mode">
                    ${fallbackMessage}
                </div>
            `;
        }
        
        this.uiManager.showNotification('üîß Modo diagn√≥stico: Interface funcional, MIDI desconectado', 'warning', 8000);
    }

    startStatsUpdater() {
        setInterval(() => {
            this.stats.messagesPerSecond = this.messageRateCounter;
            this.messageRateCounter = 0;
            
            this.uiManager.updateStats({
                ...this.stats,
                activeChannels: this.stats.activeChannels.size
            });
        }, 1000);
    }
}

// Inicializar quando a p√°gina carregar
document.addEventListener('DOMContentLoaded', () => {
    console.log('üöÄ Iniciando TerraSensoryMusic...');
    window.terraSensoryMusic = new TerraSensoryMusicSystem();
});